#include "codegen.h"
#include "common.h"

#ifdef __SDCC
extern void put_s(const char* str);
extern void put_c(char c);
#else
#include <stdio.h>
#include <stdarg.h>
#endif

#define INITIAL_OUTPUT_CAPACITY 4096

codegen_t* codegen_create(const char* output_file, symbol_table_t* symbols) {
    codegen_t* gen = (codegen_t*)cc_malloc(sizeof(codegen_t));
    if (!gen) return NULL;
    
    gen->output_file = output_file;
    gen->output_capacity = INITIAL_OUTPUT_CAPACITY;
    gen->output_buffer = (char*)cc_malloc(gen->output_capacity);
    if (!gen->output_buffer) {
        cc_free(gen);
        return NULL;
    }
    
    gen->output_size = 0;
    gen->output_buffer[0] = '\0';
    
    gen->global_symbols = symbols;
    gen->current_scope = symbols;
    gen->label_counter = 0;
    gen->string_counter = 0;
    gen->temp_counter = 0;
    gen->stack_offset = 0;
    
    gen->reg_a_used = false;
    gen->reg_hl_used = false;
    gen->reg_de_used = false;
    gen->reg_bc_used = false;
    
    return gen;
}

void codegen_destroy(codegen_t* gen) {
    if (!gen) return;
    
    if (gen->output_buffer) {
        cc_free(gen->output_buffer);
    }
    
    cc_free(gen);
}

void codegen_emit(codegen_t* gen, const char* fmt, ...) {
    if (!gen || !gen->output_buffer) return;
    
    /* Simple string append for now */
    const char* p = fmt;
    while (*p && gen->output_size < gen->output_capacity - 1) {
        gen->output_buffer[gen->output_size++] = *p++;
    }
    gen->output_buffer[gen->output_size] = '\0';
}

void codegen_emit_comment(codegen_t* gen, const char* fmt, ...) {
    codegen_emit(gen, "; ");
    codegen_emit(gen, fmt);
    codegen_emit(gen, "\n");
}

char* codegen_new_label(codegen_t* gen) {
    static char label[32];
    label[0] = 'L';
    
    /* Convert label counter to string */
    int n = gen->label_counter++;
    int i = 1;
    if (n == 0) {
        label[i++] = '0';
    } else {
        char temp[16];
        int j = 0;
        while (n > 0) {
            temp[j++] = '0' + (n % 10);
            n /= 10;
        }
        while (j > 0) {
            label[i++] = temp[--j];
        }
    }
    label[i] = '\0';
    
    return cc_strdup(label);
}

char* codegen_new_string_label(codegen_t* gen) {
    static char label[32];
    label[0] = 'S';
    
    int n = gen->string_counter++;
    int i = 1;
    if (n == 0) {
        label[i++] = '0';
    } else {
        char temp[16];
        int j = 0;
        while (n > 0) {
            temp[j++] = '0' + (n % 10);
            n /= 10;
        }
        while (j > 0) {
            label[i++] = temp[--j];
        }
    }
    label[i] = '\0';
    
    return cc_strdup(label);
}

void codegen_emit_prologue(codegen_t* gen, const char* func_name) {
    codegen_emit(gen, func_name);
    codegen_emit(gen, ":\n");
    codegen_emit(gen, "    push bc\n");
    codegen_emit(gen, "    push de\n");
    codegen_emit(gen, "    push hl\n");
}

void codegen_emit_epilogue(codegen_t* gen) {
    codegen_emit(gen, "    pop hl\n");
    codegen_emit(gen, "    pop de\n");
    codegen_emit(gen, "    pop bc\n");
    codegen_emit(gen, "    ret\n");
}

static cc_error_t codegen_function(codegen_t* gen, ast_node_t* node) {
    if (!node || node->type != AST_FUNCTION) {
        return CC_ERROR_INTERNAL;
    }
    
    codegen_emit_comment(gen, "Function: ");
    codegen_emit_comment(gen, node->data.function.name);
    
    codegen_emit(gen, node->data.function.name);
    codegen_emit(gen, ":\n");
    
    /* Generate function body */
    if (node->data.function.body) {
        /* For now, just emit a simple return */
        codegen_emit(gen, "    ld a, 0\n");
        codegen_emit(gen, "    ret\n");
    }
    
    codegen_emit(gen, "\n");
    
    return CC_OK;
}

cc_error_t codegen_generate(codegen_t* gen, ast_node_t* ast) {
    if (!gen || !ast) {
        return CC_ERROR_INTERNAL;
    }
    
    /* Emit file header */
    codegen_emit_comment(gen, "Generated by Zeal 8-bit C Compiler");
    codegen_emit_comment(gen, "Target: Z80");
    codegen_emit(gen, "\n");
    
    /* Emit standard header for ZOS */
    codegen_emit(gen, "    org 0x4000\n");
    codegen_emit(gen, "\n");
    
    /* Process AST */
    if (ast->type == AST_PROGRAM) {
        /* Generate code for all top-level declarations */
        /* Simplified for now */
        codegen_emit_comment(gen, "Program code");
    } else if (ast->type == AST_FUNCTION) {
        return codegen_function(gen, ast);
    }
    
    /* Emit main entry point if needed */
    codegen_emit(gen, "_main:\n");
    codegen_emit(gen, "    ld a, 0\n");
    codegen_emit(gen, "    ret\n");
    
    return CC_OK;
}

cc_error_t codegen_write_output(codegen_t* gen) {
    if (!gen || !gen->output_buffer) {
        return CC_ERROR_INTERNAL;
    }
    
#ifdef __SDCC
    /* ZOS file writing */
    zos_dev_t dev;
    zos_err_t err;
    uint16_t size;
    
    dev = open(gen->output_file, O_WRONLY | O_CREAT | O_TRUNC);
    if (dev < 0) {
        cc_error("Could not create output file");
        return CC_ERROR_FILE_NOT_FOUND;
    }
    
    size = (uint16_t)gen->output_size;
    err = write(dev, gen->output_buffer, &size);
    close(dev);
    
    if (err != ERR_SUCCESS) {
        cc_error("Could not write output file");
        return CC_ERROR_CODEGEN;
    }
    
    return CC_OK;
#else
    /* Desktop file writing */
    FILE* file = fopen(gen->output_file, "w");
    if (!file) {
        cc_error("Could not create output file");
        return CC_ERROR_FILE_NOT_FOUND;
    }
    
    fwrite(gen->output_buffer, 1, gen->output_size, file);
    fclose(file);
    
    return CC_OK;
#endif
}
