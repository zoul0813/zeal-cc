# Zeal 8-bit C Compiler

A C99 compiler targeting the Zeal 8-bit OS platform, powered by a Z80 CPU.

## Project Status

This is an iterative development project. Currently implemented:

- ‚úÖ Phase 1: Basic compiler structure
- ‚úÖ Phase 2: Lexer/Tokenizer (complete with C99 token support)
- ‚úÖ Phase 3: Parser (expressions, variables, assignments, function calls)
- ‚úÖ Phase 4: Symbol table (basic implementation)
- ‚úÖ Phase 5: Z80 code generator (expressions, statements, runtime helpers)
- ‚úÖ Phase 6: Control flow (if, while, for)
- ‚úÖ Phase 7: Stack-based locals and full calling convention
- üöß Phase 8: Optimizations and documentation

### Working Features ‚úÖ
- Complete C99 lexer with all token types
- Recursive descent parser with operator precedence
- Streaming file input on both host and ZOS (512-byte buffered reader; no full-file loads)
- Control flow: if/else, while, and for
- Control flow: break, continue, goto, labels
- Comparison operators (==, !=, <, >, <=, >=)
- Binary arithmetic operators (+, -, *, /, %)
- Bitwise operators (&, |, ^, ~, <<, >>)
- Logical operators (&&, ||) with short-circuit
- Function definitions and calls
- Stack-based argument passing (IX frame for params)
- Stack-based local variables
- Variable declarations and assignments
- Global variable declarations
- Single-dimension arrays (globals/locals) and array parameters (decay to pointer)
- Array and pointer indexing (8-bit indices)
- String literals for pointer/array initialization and indexing
- Unary operators: `+`, `-`, `!`, `~`, `++`, `--`
- Return statements with expressions
- Compound statements (blocks)
- Runtime library for mul/div/mod
- Expression evaluation with correct precedence
- Multiple functions per file
- `char` type and character literals
- `signed`/`unsigned` qualifiers on `char`/`int` (default unsigned)
- Pointer basics: address-of and dereference on identifiers

### In Progress üöß
- Parser target build uses 0x1700 static pool; file buffer at 0xC300 (512 B)
- Semantic pass (cc_semantic) skeleton: validation-only

### C99/ANSI C Gap (Current Limitations)
- No preprocessor (`#include`, `#define`, macros).
- Limited type system: only `int` and `char` (no `short`, `long`, floats, structs/unions/enums/typedefs).
- No full type checking or semantic analysis.
- Missing language features: switch, ternary, do/while, pointer arithmetic, multi-dimensional arrays.

### Planned Features ‚è≥
- Switch statement, do/while, ternary
- Full pointer arithmetic and multidimensional arrays
- Struct and union types
- Type checking and semantic analysis
- Optimizations (constant folding, dead code elimination)
- Preprocessor support

## Building

### Desktop Build (for testing)

```bash
make
```

This will compile the compiler for your desktop (macOS/Linux) using GCC.

### ZOS Build (target platform)

```bash
zde cmake
```

Verbose build (defines `VERBOSE` for `#ifdef VERBOSE`):
```bash
zde cmake --target verbose
```

This requires:
- SDCC 4.4.0
- ZOS_PATH environment variable set to Zeal 8-bit OS source
- ZVB SDK and coreutils

## Usage

### Desktop version:
```bash
./bin/cc input.c output.asm
```

### ZOS version:
```bash
cc input.c output.asm
```

The compiler generates Z80 assembly compatible with Zealasm.

## Examples

### Simple Return Value
**Input (simple_return.c):**
```c
int main() {
    return 42;
}
```

**Generated Assembly:**
```asm
; Generated by Zeal 8-bit C Compiler
; Target: Z80

    org 0x4000

; Program code
main:
    ld a, 42
    ret
```

### Expression with Operator Precedence
**Input (expr.c):**
```c
int main() {
    return 2 + 3 * 4;  /* Correctly evaluates to 14 */
}
```

**Generated Assembly:**
```asm
main:
    ld a, 2
    push af
    ld a, 3
    push af
    ld a, 4
    ld l, a
    pop af
; Multiplication (A * L)
    call __mul_a_l
    ld l, a
    pop af
    add a, l
    ret
```

### Multiple Functions
**Input (params.c):**
```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 10;
    int sum = add(x, y);

    return sum + add(2, 3);
}
```

**Generated Assembly:**
```asm
add:
    push ix
    ld ix, 0
    add ix, sp
    ld a, (ix+4)
    push af
    ld a, (ix+6)
    ld l, a
    pop af
    add a, l
    pop ix
    ret

main:
    ld a, 5
    ld (x), a
    ld a, 10
    ld (y), a
    call add
    ret
```

## Testing

**Important**: All test input and output files must remain in the `tests/` directory. Never write test output to `/tmp` or any location outside the project.

Run individual tests:
```bash
./bin/cc tests/simple_return.c tests/simple_return.asm      # Simple return
./bin/cc tests/return16.c tests/return16.asm  # 16-bit return value
./bin/cc tests/expr.c tests/expr.asm  # Expression precedence
./bin/cc tests/assign.c tests/assign.asm  # Assignment chaining
./bin/cc tests/compares.c tests/compares.asm  # Comparisons
./bin/cc tests/math.c tests/math.asm  # Math ops
./bin/cc tests/if.c tests/if.asm      # If statement
./bin/cc tests/while.c tests/while.asm  # While loop
./bin/cc tests/for.c tests/for.asm    # For loop
./bin/cc tests/params.c tests/params.asm  # Locals + function parameters
./bin/cc tests/comp.c tests/comp.asm  # Factorial comprehensive
./bin/cc tests/do_while.c tests/do_while.asm  # Do/while (expected fail)
./bin/cc tests/unary.c tests/unary.asm  # Unary ops
./bin/cc tests/char.c tests/char.asm    # Char literals
./bin/cc tests/global.c tests/global.asm  # Global variables
./bin/cc tests/pointer.c tests/pointer.asm  # Pointer + string literal indexing
```

All test artifacts (`.asm`, `.o`, `.bin`, etc.) are stored in `tests/` for version control and review.

**Note**: When adding a new test source in `tests/`, also update `test.zs` so the Zeal headless script runs the new case on target hardware. Expected failures are tracked in `test.py`.

## Architecture

- `src/main.c` - Entry point and file I/O
- `src/lexer.c` - Lexical analysis (tokenization)
- `src/parser.c` - Syntax analysis (AST generation)
- `src/symbol.c` - Symbol table and type system
- `src/codegen.c` - Z80 assembly code generation

## Current Limitations

- Parser lacks do/while, ternary, switch, break/continue
- Fixed static pool allocator; parser uses 0x1700 on target (no dynamic malloc)
- 512-byte input reader buffer; very large source files are not supported
- No optimization passes yet
- Limited error reporting
- `long` (32-bit) is currently unsupported
- Not yet supported in codegen: do/while, ternary operator, structs/unions
- Array init is limited to string literals for `char[]`
- Pointer support is limited to address-of/deref on identifiers and array-style indexing

## Next Steps

We will iterate on this implementation, adding:
1. Semantic analysis and type checking
2. Extend parser support (do/while, ternary, logical/bitwise, switch/break/continue)
3. Complete codegen for missing constructs (structs/unions, pointer arithmetic, multidimensional arrays, array init)
4. Preprocessor support
5. Optimization passes
6. Register allocation

## License

See LICENSE file for details.
